#!/usr/bin/env python

from optparse import OptionParser
from os import path
import cPickle as pickle
import re
import sys
import urllib
import xml.etree.cElementTree as etree


_refgram = {'A': [(14, 6)],
            'BAI': [(9, 6)],
            'BAhE': [(19, 11)],
            'BE': [(5, 7)],
            'BEI': [(5, 7)],
            'BEhO': [(5, 7)],
            'BIhE': [(18, 5)],
            'BIhI': [(14, 16)],
            'BO': [(5, 3), (15, 6), (18, 17)],
            'BOI': [(18, 6)],
            'BU': [(17, 4)],
            'BY': [(17, 2)],
            'CAI': [(13, 4)],
            'CAhA': [(10, 19)],
            'CEI': [(7, 5)],
            'CEhE': [(14, 11), (16, 7)],
            'CO': [(5, 8)],
            'COI': [(6, 11), (13, 14)],
            'CU': [(9, 2)],
            'CUhE': [(10, 24)],
            'DAhO': [(7, 13)],
            'DOI': [(13, 14)],
            'DOhU': [(13, 14)],
            'FA': [(9, 3)],
            'FAhA': [(10, 2)],
            'FAhO': [(19, 15)],
            'FEhE': [(10, 11)],
            'FEhU': [(9, 5)],
            'FIhO': [(9, 5)],
            'FOI': [(17, 6)],
            'FUhA': [(18, 16)],
            'FUhE': [(19, 8)],
            'FUhO': [(19, 8)],
            'GA': [(14, 5)],
            'GAhO': [(14, 16)],
            'GEhU': [(8, 3)],
            'GI': [(14, 5)],
            'GIhA': [(14, 3)],
            'GOI': [(8, 3)],
            'GOhA': [(7, 6)],
            'GUhA': [(14, 3)],
            'I': [(19, 2)],
            'JA': [(14, 3)],
            'JAI': [(9, 12)],
            'JOI': [(14, 14)],
            'JOhI': [(18, 15)],
            'KE': [(5, 5)],
            'KEI': [(11, 1)],
            'KEhE': [(5, 5)],
            'KI': [(10, 13)],
            'KOhA': [(7, 1)],
            'KU': [(6, 2), (10, 1)],
            'KUhE': [(18, 6)],
            'KUhO': [(8, 1)],
            'LA': [(6, 2)],
            'LAU': [(17, 14)],
            'LAhE': [(6, 10)],
            'LE': [(6, 2)],
            'LEhU': [(19, 9)],
            'LI': [(18, 5)],
            'LIhU': [(19, 9)],
            'LOhO': [(18, 17)],
            'LOhU': [(19, 9)],
            'LU': [(19, 9)],
            'LUhU': [(6, 10)],
            'MAI': [(18, 19), (19, 1)],
            'MAhO': [(18, 6)],
            'ME': [(5, 10), (18, 1)],
            'MEhU': [(5, 11)],
            'MOI': [(5, 11)],
            'MOhE': [(18, 18)],
            'MOhI': [(10, 8)],
            'NA': [(14, 3), (15, 7)],
            'NAI': [(14, 3), (15, 7)],
            'NAhE': [(15, 4)],
            'NAhU': [(18, 18)],
            'NIhE': [(18, 18)],
            'NIhO': [(19, 3)],
            'NOI': [(8, 1)],
            'NU': [(11, 1)],
            'NUhA': [(18, 19)],
            'NUhI': [(14, 11), (16, 7)],
            'NUhU': [(14, 11)],
            'PA': [(18, 2)],
            'PEhE': [(14, 11)],
            'PEhO': [(18, 6)],
            'PU': [(10, 4)],
            'RAhO': [(7, 6)],
            'ROI': [(10, 9)],
            'SA': [(19, 13)],
            'SE': [(5, 1), (9, 4)],
            'SEI': [(19, 12)],
            'SEhU': [(19, 12)],
            'SI': [(19, 13)],
            'SOI': [(7, 8)],
            'SU': [(19, 13)],
            'TAhE': [(10, 9)],
            'TEI': [(17, 6)],
            'TEhU': [(18, 15)],
            'TO': [(19, 12)],
            'TOI': [(19, 12)],
            'TUhE': [(19, 2)],
            'TUhU': [(19, 2)],
            'UI': [(13, 1)],
            'VA': [(10, 2)],
            'VAU': [(14, 9)],
            'VEI': [(18, 5)],
            'VEhA': [(10, 5)],
            'VEhO': [(19, 5)],
            'VIhA': [(10, 7)],
            'VUhO': [(8, 8)],
            'VUhU': [(18, 5)],
            'XI': [(18, 13)],
            'Y': [(19, 14)],
            'ZAhO': [(10, 10)],
            'ZEI': [(4, 6)],
            'ZEhA': [(10, 5)],
            'ZI': [(10, 4)],
            'ZIhE': [(8, 4)],
            'ZO': [(19, 10)],
            'ZOI': [(19, 10)],
            'ZOhU': [(16, 2), (19, 4)]}


class Find():

    def __init__(self):
        parser = OptionParser(usage='makfa find [options] [query]')
        parser.add_option('-t', '--type', dest='type', help='Type of word')
        parser.add_option('-v', '--valsi', dest='valsi',
                          help='Match entry name')
        parser.add_option('-g', '--gloss', dest='gloss',
                          help='Match against gloss words')
        parser.add_option('-r', '--rafsi', dest='rafsi',
                          help='Match against rafsi affixes')
        parser.add_option('-s', '--selmaho', dest='selmaho',
                          help='Match against selmaho grammatical class')
        parser.add_option('-d', '--definition', dest='definition',
                          help='Match against definitions by regexp')
        parser.add_option('-n', '--notes', dest='notes',
                          help='Match against notes by regexp')
        parser.add_option('-R', '--regexp', action='store_true', dest='regexp',
                          help='Match more fields by regexp')
        parser.add_option('-D', '--show-definition', action='store_true',
                          dest='show_definition',
                          help='Show definition of matching entries')
        parser.add_option('-S', '--show', action='store_true', dest='show',
                          help='Show all data of matching entries')
        self.parser = parser

    def results(self, argv, db):
        (options, args) = self.parser.parse_args(argv)
        self.options = options
        opts = {'type': options.type, 'valsi': options.valsi,
                'gloss': options.gloss, 'rafsi': options.rafsi,
                'selmaho': options.selmaho, 'definition': options.definition,
                'notes': options.notes, 'regexp': options.regexp,
                'query': ' '.join(args)}
        return db.query(**opts)

    def parse(self, argv, db):
        results = self.results(argv, db)
        if results:
            if self.options.show:
                Show().parse(results, db)
            elif self.options.show_definition:
                Definition().parse(results, db)
            else:
                for entry in results:
                    print entry


class Console():

    def __init__(self):
        self.parser = OptionParser(usage='makfa console')

    def parse(self, argv, db):
        self.parser.parse_args(argv)
        import readline
        finder = Find()
        shower = Show()
        while True:
            input = raw_input('> ').split()
            results = finder.results(input, db)
            results.reverse()
            if results:
                shower.parse(results, db)


class Command():

    def __init__(self):
        self.name = self.__class__.__name__.lower()
        self.parser = OptionParser(usage='makfa %s [entries]' % self.name)
        self.parser.add_option('-q', '--quiet', action='store_true',
                               dest='quiet', help='Pipe friendly output')

    def parse(self, argv, db):
        (options, args) = self.parser.parse_args(argv)
        if args:
            for entry in args:
                entry = entry.replace('h', "'")
                if entry in db:
                    self.output(entry, db, options)
        else:
            while True:
                entry = raw_input().replace('h', "'")
                if entry in db:
                    self.output(entry, db, options)

    def output(self, entry, db, options):
        if options.quiet:
            if db[entry][self.name]:
                print db[entry][self.name].encode('utf-8')
        else:
            print ' %s%s : %s' % (' ' * (db._longest-len(entry)), entry,
                                  (db[entry][self.name] or '').encode('utf-8'))


class References(Command):

    def output(self, entry, db, options):
        if db[entry]['notes']:
            refs = re.findall(r'\{(.+?)\}', db[entry]['notes'])
            if options.quiet:
                for cf in refs:
                    print cf
            else:
                print ' %s%s : %s' % (' ' * (db._longest-len(entry)), entry,
                                      ' '.join(refs))


class Show(Command):

    def __init__(self):
        self.parser = OptionParser(usage='makfa show [entries]')

    def output(self, entry, db, options):
        meta = [db[entry]['type'],
                db[entry]['selmaho'],
                ', '.join(['-%s-' % r for r in db[entry]['rafsi']])]
        print ' %s%s : %s' % (' ' * (db._longest-len(entry)),
                             entry, ' '.join([i for i in meta if i]))
        defn = db[entry]['definition'].encode('utf-8')
        print ' %s : %s' % (' ' * db._longest, defn)
        for place in db[entry]['places']:
            places = [('"%s" in the sense of "%s"' % i if i[1] else
                       '"%s"' % i[0])
                      for i in db[entry]['places'][place]]
            print ' %s : (x%d) %s' % (' ' * db._longest, place,
                                      ', '.join(places).encode('utf-8'))
        if db[entry]['selmaho']:
            selmaho = re.search(r'^([a-zA-Z]+)', db[entry]['selmaho']).group(1)
            if selmaho in _refgram:
                urls = ['<http://dag.github.com/cll/%s/%s/>' % i
                        for i in _refgram[selmaho]]
                print ' %s : %s' % (' ' * db._longest, ', '.join(urls))
        if db[entry]['notes']:
            notes = db[entry]['notes'].encode('utf-8')
            print ' %s : %s' % (' ' * db._longest, notes)
        print


class Type(Command):
    pass


class Gloss(Command):

    def __init__(self):
        Command.__init__(self)
        self.parser.add_option('-p', '--place', type='int', default=1,
                               dest='place', help='Gloss word place')

    def output(self, entry, db, options):
        if options.place in db[entry]['places']:
            if options.quiet:
                print db[entry]['places'][options.place][0][0]
            else:
                places = [('"%s" in the sense of "%s"' % i if i[1] else
                           '"%s"' % i[0])
                          for i in db[entry]['places'][options.place]]
                print ' %s%s : %s' % (' ' * (db._longest-len(entry)),
                                      entry, ', '.join(places).encode('utf-8'))
        else:
            if options.quiet:
                print
            else:
                print ' %s%s : ' % (' ' * (db._longest-len(entry)), entry)


class Rafsi(Command):
    def output(self, entry, db, options):
        if options.quiet:
            print ' '.join(db[entry]['rafsi'])
        else:
            rafsi = ['-%s-' % r for r in db[entry]['rafsi']]
            print ' %s%s : %s' % (' ' * (db._longest-len(entry)),
                                  entry, ', '.join(rafsi))


class Selmaho(Command):

    def output(self, entry, db, options):
        if options.quiet:
            if db[entry]['selmaho']:
                print db[entry]['selmaho']
        else:
            urls = []
            if db[entry]['selmaho']:
                selmaho = re.search(r'^([a-zA-Z]+)', db[entry]['selmaho']).group(1)
                if selmaho in _refgram:
                    urls = ['<http://dag.github.com/cll/%s/%s/>' % i
                            for i in _refgram[selmaho]]
            print ' %s%s : %s %s' % (' ' * (db._longest-len(entry)), entry,
                                     db[entry][self.name] or '',
                                     ', '.join(urls))


class Definition(Command):
    pass


class Notes(Command):
    pass


class Dictionary():

    def __init__(self):
        try:
            self._db = pickle.load(open(path.expanduser('~/.makfa.dump')))
        except:
            sys.stderr.write('(Fetching dictionary, this may take a minute.)\n')
            db = {'order': [], 'entries': {}}
            url = 'http://jbovlaste.lojban.org/export/xml-export.html?lang=en'
            tree = etree.parse(urllib.urlopen(url))
            types = ['gismu', 'cmavo', 'cmavo cluster', 'lujvo', "fu'ivla",
                     'experimental gismu', 'experimental cmavo', 'cmene']
            for type in types:
                for valsi in tree.findall('//valsi'):
                    if valsi.get('type') == type:
                        word = valsi.get('word')
                        db['order'].append(word)
                        db['entries'][word] = {'type': type, 'rafsi': [],
                                               'selmaho': None,
                                               'definition': None,
                                               'notes': None, 'places': {}}
                        for child in valsi.getchildren():
                            if child.tag == 'rafsi':
                                db['entries'][word]['rafsi'].append(child.text)
                            elif child.tag == 'selmaho':
                                db['entries'][word]['selmaho'] = child.text
                            elif child.tag == 'definition':
                                db['entries'][word]['definition'] = \
                                    self._prettyplace(child.text)
                            elif child.tag == 'notes':
                                db['entries'][word]['notes'] = \
                                    self._prettyplace(child.text)
            for valsi in tree.findall('//nlword'):
                word = valsi.get('valsi')
                place = int(valsi.get('place') or '1')
                sense = valsi.get('sense')
                if place not in db['entries'][word]['places']:
                    db['entries'][word]['places'][place] = []
                db['entries'][word]['places'][place]. \
                    append((valsi.get('word'), sense))
            pickle.dump(db, open(path.expanduser('~/.makfa.dump'), 'w'), -1)
            self._db = db
        self._longest = sorted([len(i) for i in self._db['order']])[-1]

    def find(self, type=None, valsi=None, gloss=None, rafsi=None,
             selmaho=None, definition=None, notes=None, regexp=False):
        results = self._db['order']
        results = self._type(results, type, regexp)
        results = self._valsi(results, valsi, regexp)
        results = self._gloss(results, gloss, regexp)
        results = self._rafsi(results, rafsi, regexp)
        results = self._selmaho(results, selmaho, regexp)
        results = self._definition(results, definition)
        results = self._notes(results, notes)
        return results

    def query(self, query=None, type=None, valsi=None, gloss=None,
              rafsi=None, selmaho=None, definition=None, notes=None,
              regexp=False):
        results = []
        args = {'gloss': gloss, 'valsi': valsi, 'rafsi': rafsi,
                'selmaho': selmaho, 'definition': definition, 'notes': notes,
                'regexp': regexp, 'type': type}
        if query:
            order = ['gloss', 'valsi', 'rafsi',
                     'selmaho', 'definition', 'notes']
            for arg in order:
                copyarg = dict(args)
                copyarg[arg] = query
                results.extend(self.find(**copyarg))
            dupes = results
            results = []
            [results.append(i) for i in dupes if i not in results]
            return results
        else:
            return self.find(**args)

    def _type(self, inlist, type, regexp):
        if not type: return inlist
        if not regexp: type = type.lower()
        return [i for i in inlist
                  if regexp and
                     re.search(type, self[i]['type'], re.IGNORECASE) or
                     type == self[i]['type']]

    def _valsi(self, inlist, valsi, regexp):
        if not valsi: return inlist
        valsi = valsi.replace('h', "'")
        return [i for i in inlist
                  if regexp and re.search(valsi, i, re.IGNORECASE) or
                     valsi == i]

    def _gloss(self, inlist, gloss, regexp):
        if not gloss: return inlist
        return [v for v in inlist
                  if any([regexp and
                          any([re.search(gloss, i, re.IGNORECASE)
                               for i in [i[0] for i in i]]) or
                          gloss in [i[0] for i in i]
                          for i in self[v]['places'].values()])]

    def _rafsi(self, inlist, rafsi, regexp):
        if not rafsi: return inlist
        rafsi = rafsi.replace('h', "'")
        return [i for i in inlist if regexp and
                                     any([re.search(rafsi, a, re.IGNORECASE)
                                          for a in self[i]['rafsi']]) or
                                     rafsi in self[i]['rafsi']]

    def _selmaho(self, inlist, selmaho, regexp):
        if not selmaho: return inlist
        if not regexp:
            selmaho = selmaho.upper().replace('H', 'h')
        return [i for i in inlist 
                  if self[i]['selmaho'] and (regexp and
                     re.search(selmaho, self[i]['selmaho'], re.IGNORECASE) or
                     self[i]['selmaho'] == selmaho)]

    def _definition(self, inlist, definition):
        if not definition: return inlist
        return [i for i in inlist
                  if re.search(definition,
                               self[i]['definition'],
                               re.IGNORECASE)]

    def _notes(self, inlist, notes):
        if not notes: return inlist
        return [i for i in inlist
                  if self[i]['notes'] and
                     re.search(notes, self[i]['notes'], re.IGNORECASE)]

    def _prettyplace(self, defn):
        def f(m):
            res = m.group(1).replace('_', '')
            return res.replace('{', '').replace('}', '')
        return re.sub(r'\$(.+?)\$', f, defn.replace('\n', ' '))

    def __getitem__(self, key):
        return self._db['entries'][key]

    def __iter__(self):
        return iter(self._db['order'])


if __name__ == '__main__':
    commands = {'find': Find, 'console': Console, 'show': Show,
                'references': References, 'type': Type, 'rafsi': Rafsi,
                'gloss': Gloss, 'selmaho': Selmaho,
                'definition': Definition, 'notes': Notes}

    if len(sys.argv) == 1:
        print 'Usage: makfa <command> [options]'
        print
        print 'Commands:'
        for command in commands.keys():
            print '  %s' % command

    elif sys.argv[1] not in commands:
        similar = [i for i in commands if i.startswith(sys.argv[1])]
        if not similar:
            print 'Unknown command.'
        elif len(similar) > 1:
            print 'Ambiguous command resolution: %s' % ', '.join(similar)
        else:
            try:
                commands[similar[0]]().parse(sys.argv[2:], Dictionary())
            except:
                pass

    else:
        try:
            commands[sys.argv[1]]().parse(sys.argv[2:], Dictionary())
        except:
            pass

